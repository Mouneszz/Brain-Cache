So if we use aggregate function the result row size will be changed.
- To tackle that we have to use window function so **the result row size is same as the table size**.
Example:
- If we have to find the total earning of each store we can use `sum()` and group by  `store_name` but if we want to have  transaction id with these
- Like we need the same table but with an extra column which have the total earning of the shop.

Syntax:
- The having an `over()` next to a normal aggregate function.
- In `over()` we can give two arguments.
- `partition by` and `order by`
`partition by ----` -  only does the operation(aggregation) for -----. 
`order by ` similar to normal but 
**Aggregate function**

```mysql
select tran_id,s_name,amount,
 sum(amount) over (partition by s_name order by tran_id desc) as Total_amount
from shops;
```
here it the original  table size is not changed it create a new column  as `Total_amount` and add that to every respective column.
- Every shop `A` will have the sum of all A amount in  a specific column .
- Order by   - order `tran_id` by  partition by partition.

**It is similar to all other aggregate functions so dont need to see**
 

**RANKING**

Row Number:
Create a unique number for each row 
```mysql
%%sql
select tran_id,s_name,amount, row_number() over(order by amount desc) as NUM_DESC from shops;
```
Here this what s does is  it partition first by the name and in the name it gives the number by the order of amount in desc order.

Delete duplicate using `row_number` 
```mysql
with employee_dedu as(
select id,name,hiredate,
row_number() over(partition by id order by hiredate asc) as newnum 
from employee
)
select id,name,hiredate from employee_dedu where newnum=1;
```

**Rank**
The difference between  `row_number` and `rank` is that:
in `row_num` we get unique  but in rank if the constraint for the order is same than the same number for both and for the next number we row number will be next of next.

for example **top three marks in a class , if the first and second have same mark, then the rank will be 1 for them and for the third person the rank will be `3`.**
```mysql
select tran_id,s_name , rank() over(order by amount desc) as rank_num
from shops;
```


**dense rank**
Same as rank, but the main difference is
**Top three marks in a class , if the first and second have same mark, then the rank will be 1 for them and for the third person the rank will be `2`.**
```mysql
select tran_id,s_name , rank() over(order by amount desc) as rank_num
from shops;
```

**NTILE**
When we want to rank them  by  group we can use ntile

```mysql
select tran_id,s_name , ntile(4) over(order by amount desc) as rank_num
from shops;
```
here  the rank number is classified into 4 parts 1,2,3,4 based on the amount.
